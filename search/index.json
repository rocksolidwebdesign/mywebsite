[{"content":"I made a software raytracer and rasterizer.\nhttp://github.com/rocksolidwebdesign/cxxray\nCover Photo\nThe original Utah Teapot used as a reference by Martin Newell, a computer scientist and pioneer of 3D graphics.\nCredit: Marshall Astor\n","date":"2022-11-05T20:00:00Z","image":"http://www.rocksolidwebdesign.com/images/wikipedia/Original_Utah_Teapot-crop.png","permalink":"http://www.rocksolidwebdesign.com/p/cxxray/","title":"A C++ Software Rasterizer"},{"content":"A simple compiler written in C\nhttp://github.com/rocksolidwebdesign/eparc\nCover Photo\nThe Dragon is a common metaphorical symbol in the topic of compilers.\nCredit: Ravit Sages\n","date":"2022-11-05T19:00:00Z","image":"http://www.rocksolidwebdesign.com/images/unsplash/ravit-sages-gXyptwjk9aw-unsplash-crop.png","permalink":"http://www.rocksolidwebdesign.com/p/eparc/","title":"A Simple Compiler"},{"content":"I created this fractal renderer.\nIt runs right in your browser, click the link and have fun.\nhttps://rocksolidwebdesign.github.io/mandle.js/\nCover Photo\nA colorized rendering of the Mandlebrot Set, so named for Benoit Mandlebrot.\nThere are no colors associated with the math but colors can be assigned based on the results to create these intricate pictures.\nCredit: Binette228\n","date":"2022-11-05T18:00:00Z","image":"http://www.rocksolidwebdesign.com/images/wikipedia/Mandelbrot_set_image-crop.png","permalink":"http://www.rocksolidwebdesign.com/p/mandle-js/","title":"A Study on The Mandlebrot Set"},{"content":"The Chrono Library The \u0026lt;chrono\u0026gt; library contains functions for handling time related things.\nThe code in these examples uses the C++20 language standard.\nClock Types Use the system_clock when you want to get the current calendar date and time.\nUse the steady_clock when you want to measure time elapsed. This is likely suitable for many benchmarking needs.\nUse the high_resolution_clock for benchmarking and profiling. This may be the same as the previous two, so it may be better to implement your own high resolution clock using OS features. This guide will explain how to do this for Windows and Linux.\nGetting The Current Time Using chrono we can check the current date and time.\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; using namespace std; using namespace std::chrono; int main() { time_point\u0026lt;system_clock\u0026gt; t = system_clock::now(); cout \u0026lt;\u0026lt; \u0026#34;Current Time: \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; } This program will output something like this\n1 Current Time: 2021-06-18 02:37:59.7503284 Measuring Time It is common to want to measure how much time something takes to run, like for example when benchmarking your code for performance.\nFor this purpose, we can use the steady_clock to measure time elapsed like a stopwatch.\nThe Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;ratio\u0026gt; using namespace std; using namespace std::chrono; using namespace std::chrono_literals; using std::this_thread::sleep_for; int main() { time_point\u0026lt;steady_clock\u0026gt; startTime = steady_clock::now(); sleep_for(150ms); time_point\u0026lt;steady_clock\u0026gt; endTime = steady_clock::now(); duration\u0026lt;double\u0026gt; s = endTime - startTime; duration\u0026lt;double,milli\u0026gt; ms = endTime - startTime; auto us = duration_cast\u0026lt;microseconds\u0026gt;(endTime - startTime); auto ns = endTime - startTime; cout \u0026lt;\u0026lt; \u0026#34;Total seconds: \u0026#34; \u0026lt;\u0026lt; s.count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Total milliseconds: \u0026#34; \u0026lt;\u0026lt; ms.count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Total microseconds: \u0026#34; \u0026lt;\u0026lt; us.count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Total nanoseconds: \u0026#34; \u0026lt;\u0026lt; ns.count() \u0026lt;\u0026lt; endl; } This program will output something like the following\n1 2 3 4 Total seconds: 0.162912 Total milliseconds: 162.912 Total microseconds: 162912 Total nanoseconds: 162912300 Line By Line We will first get the current time and then do some lengthy operation to see how long it takes.\n1 time_point\u0026lt;steady_clock\u0026gt; startTime = steady_clock::now(); We will just simulate something taking a long time with the sleep function.\nThe sleep function will try to sleep for some amount of time, but the actual amount of time is likely to vary due to system noise.\n1 sleep_for(150ms); After the operation we will again obtain the current time.\n1 time_point\u0026lt;steady_clock\u0026gt; endTime = steady_clock::now(); We can then find the total time elapsed by subtracting the start and end times.\nFor example, if the start time is 9:30AM and the end time is 9:35AM then five minutes have gone by.\nThis line will get the elapsed time in seconds as a floating point number.\n1 duration\u0026lt;double\u0026gt; s = endTime - startTime; We can get a different resolution by assigning to a duration with a different ratio.\nThis line will get the time in milliseconds as a float.\n1 duration\u0026lt;double,milli\u0026gt; ms = endTime - startTime; We can get a different resolution with duration_cast.\nThis line will get the time in microseconds as an integer.\n1 auto us = duration_cast\u0026lt;microseconds\u0026gt;(endTime - startTime); The default resolution will be integer nanoseconds.\n1 auto ns = endTime - startTime; The .count() function returns the int or float value of the duration.\nA Timer Class Here is an example time measurement class you can use.\nThis class provides a slightly nicer more convenience syntax for performance benchmarking your code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;ratio\u0026gt; using namespace std; using namespace std::chrono; using namespace std::chrono_literals; using std::this_thread::sleep_for; class Stopwatch { public: using Clock = steady_clock; using Time = time_point\u0026lt;Clock\u0026gt;; using Duration = duration\u0026lt;double,milli\u0026gt;; private: Time startTime; Time endTime; public: Stopwatch() { start(); } void start() { startTime = Clock::now(); endTime = startTime; } Duration stop() { endTime = Clock::now(); return get(); } Duration get() { return endTime - startTime; } }; int main() { Stopwatch s; sleep_for(150ms); auto totalTime = s.stop(); auto ns = duration_cast\u0026lt;nanoseconds\u0026gt;(totalTime); cout \u0026lt;\u0026lt; \u0026#34;Total milliseconds: \u0026#34; \u0026lt;\u0026lt; totalTime.count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Total nanoseconds: \u0026#34; \u0026lt;\u0026lt; ns.count() \u0026lt;\u0026lt; endl; } Cover Photo\nCredit: Max Shein\n","date":"2022-11-05T18:00:00Z","image":"http://www.rocksolidwebdesign.com/images/unsplash/max-shein-A5vzfNHB54I-unsplash-crop.png","permalink":"http://www.rocksolidwebdesign.com/p/cpp-performance-timer/","title":"C++ Performance Timer"},{"content":"How To Handle Circular Dependencies Circular dependencies can raise challenges and frustration.\nEliminate Circular Dependencies Any time A depends on B and B depends on A, a third object C can be created where C depends on both A and B. This eliminates the circular dependency entirely.\nThe following example has a problem.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 struct Vector2 { int x = 0; int y = 0; Vector2\u0026amp; operator=(const Vector3\u0026amp; p) { // assigning 3d to 2d truncates x = p.x; y = p.y; return *this; } }; struct Vector3 { int x = 0; int y = 0; int z = 1; Vector3\u0026amp; operator=(const Vector2\u0026amp; p) { // assigning 2d to 3d sets the homogenous coor x = p.x; y = p.y; z = 1; return *this; } }; int main() { Vector2 latLngA{3, 4}; Vector3 worldPosA{5, 5, 2}; // assigning 3d to 2d latLngA = worldPosA; Vector2 latLngB{6, 6}; Vector3 worldPosB{7, 8, 9}; // assigning 2d to 3d worldPosB = latLngB; } This begets a compile error because Vector2 needs to know about Vector3 but Vector3 has not been defined yet.\nIf we reverse the order, then we just get the reverse problem where Vector3 would need to know about Vector2 but Vector2 won\u0026rsquo;t be defined yet.\nThe solution is to create a third higher level layer that accepts and operates on our two vector types so that our vector types don\u0026rsquo;t need to know about each other.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct Vector2 { int x = 0; int y = 0; }; struct Vector3 { int x = 0; int y = 0; int z = 1; }; Vector2\u0026amp; operator=(Vector2\u0026amp; p, const Vector3\u0026amp; q) { p.x = q.x; p.x = q.y; return p; } Vector3\u0026amp; operator=(Vector3\u0026amp; p, const Vector2\u0026amp; q) { p.x = q.x; p.y = q.y; p.z = 1; return p; } Forward Declaration Eliminating circular dependencies entirely is most desireable.\nAnother option is to forward declare.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 struct Vector3; struct Vector2 { int x = 0; int y = 0; Vector2\u0026amp; operator=(const Vector3\u0026amp; p) { x = p.x; y = p.y; return *this; } }; struct Vector3 { int x = 0; int y = 0; int z = 1; Vector3\u0026amp; operator=(const Vector2\u0026amp; p) { x = p.x; y = p.y; z = 1; return *this; } }; Here we simply tell Vector2 that Vector3 will exist at some point in the future.\nThis allows the code to compile, however, Vector2 can only refer to either references or pointers to Vector3 because we don\u0026rsquo;t yet know what the in memory layout of Vector3 looks like.\nCover Photo\nCredit: Joshua Lawrence\n","date":"2022-11-05T18:00:00Z","image":"http://www.rocksolidwebdesign.com/images/unsplash/joshua-lawrence-6AHluNMEpQ4-unsplash-crop.png","permalink":"http://www.rocksolidwebdesign.com/p/circular-dependencies/","title":"Circular Dependencies"},{"content":"Containers have a quirk, let\u0026rsquo;s look at it.\nNoexcept Consider a hypothetical case of a 2D Point class, possibly used for math or graphics.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using std::cout; using std::endl; using std::vector; struct Point { int x = 0; int y = 0; Point() { cout \u0026lt;\u0026lt; \u0026#34;default ctor\u0026#34; \u0026lt;\u0026lt; endl; } Point(int x_, int y_) : x{x_} , y{y_} { cout \u0026lt;\u0026lt; \u0026#34;param ctor\u0026#34; \u0026lt;\u0026lt; endl; } Point(const Point\u0026amp;) { cout \u0026lt;\u0026lt; \u0026#34;copy ctor\u0026#34; \u0026lt;\u0026lt; endl; } Point\u0026amp; operator=(const Point\u0026amp;) { cout \u0026lt;\u0026lt; \u0026#34;copy assign\u0026#34; \u0026lt;\u0026lt; endl; return *this; } Point(Point\u0026amp;\u0026amp;) { cout \u0026lt;\u0026lt; \u0026#34;move ctor\u0026#34; \u0026lt;\u0026lt; endl; } Point\u0026amp; operator=(Point\u0026amp;\u0026amp;) { cout \u0026lt;\u0026lt; \u0026#34;move assign\u0026#34; \u0026lt;\u0026lt; endl; return *this; } }; int main() { vector\u0026lt;Point\u0026gt; points; for (int i = 0; i \u0026lt; 5; i++) { cout \u0026lt;\u0026lt; \u0026#34;Loop \u0026#34; \u0026lt;\u0026lt; (i + 1) \u0026lt;\u0026lt; endl; points.emplace_back(1, 2); cout \u0026lt;\u0026lt; endl; } } If we create and fill a vector of these points as in the example code above then we get the following output\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Loop 1 param ctor Loop 2 param ctor copy ctor Loop 3 param ctor copy ctor copy ctor Loop 4 param ctor copy ctor copy ctor copy ctor Loop 5 param ctor copy ctor copy ctor copy ctor copy ctor We see the copy constructor is called, not the move constructor.\nThis could be very wasteful for larger data types like image containers.\nThe solution is to mark the move ctor and move assign as noexcept.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using std::cout; using std::endl; using std::vector; struct Point { int x = 0; int y = 0; Point() { cout \u0026lt;\u0026lt; \u0026#34;default ctor\u0026#34; \u0026lt;\u0026lt; endl; } Point(int x_, int y_) : x{x_} , y{y_} { cout \u0026lt;\u0026lt; \u0026#34;param ctor\u0026#34; \u0026lt;\u0026lt; endl; } Point(const Point\u0026amp;) { cout \u0026lt;\u0026lt; \u0026#34;copy ctor\u0026#34; \u0026lt;\u0026lt; endl; } Point\u0026amp; operator=(const Point\u0026amp;) { cout \u0026lt;\u0026lt; \u0026#34;copy assign\u0026#34; \u0026lt;\u0026lt; endl; return *this; } Point(Point\u0026amp;\u0026amp;) noexcept { cout \u0026lt;\u0026lt; \u0026#34;move ctor\u0026#34; \u0026lt;\u0026lt; endl; } Point\u0026amp; operator=(Point\u0026amp;\u0026amp;) noexcept { cout \u0026lt;\u0026lt; \u0026#34;move assign\u0026#34; \u0026lt;\u0026lt; endl; return *this; } }; int main() { vector\u0026lt;Point\u0026gt; points; for (int i = 0; i \u0026lt; 5; i++) { cout \u0026lt;\u0026lt; \u0026#34;Loop \u0026#34; \u0026lt;\u0026lt; (i + 1) \u0026lt;\u0026lt; endl; points.emplace_back(1, 2); cout \u0026lt;\u0026lt; endl; } } The only change here is that the move constructor and move assignment operator have been marked noexcept.\nThis then gives the following output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Loop 1 param ctor Loop 2 param ctor move ctor Loop 3 param ctor move ctor move ctor Loop 4 param ctor move ctor move ctor move ctor Loop 5 param ctor move ctor move ctor move ctor move ctor Cover Photo\nCredit: Guillermo Alvarez\n","date":"2022-11-05T18:00:00Z","image":"http://www.rocksolidwebdesign.com/images/unsplash/guillermo-alvarez--1bgSTV8E4M-unsplash-crop.png","permalink":"http://www.rocksolidwebdesign.com/p/noexcept-vectors/","title":"Noexcept Vectors"},{"content":"I made some virtual robots that learn through a geneic algorithm.\nThis is an interactive demo, you can try it in your browser.\nhttp://rocksolidwebdesign.github.io/jsbots/\nCover Photo\nCredit: Jochen Van Wylick\n","date":"2022-11-05T17:00:00Z","image":"http://www.rocksolidwebdesign.com/images/unsplash/jochen-van-wylick-Y40Ga3oahAs-unsplash-crop.jpg","permalink":"http://www.rocksolidwebdesign.com/p/js-bots/","title":"A Robot Brain Simulation"},{"content":"There is a lot of power on the command line, but it can be difficult to master. I hope to give you a taste of that power with a survey of cool things you can do with the find utility on most unix like systems.\nBash Power Commands for Mere Mortals When you provide the -exec switch to find you can process multiple files at once, in any way you like: resize images, rename mp3s, add entire directory trees to your workgroup. You name it and find -exec can do it - well, name something you can do with bash :)\nActually Finding Stuff NOTE: If you already know the basics of the common linux command line find utility, you can skip to the next section.\nFind, simply put, finds files. If you ever forgot where you put your 1994 tax return, you could use find to find it. Like most commands in bash, all of it’s options are layed out for you in the manual page (see man find). Also like most commands in bash, the options are quite arcane and so plentiful that the uninitiated are left rather bewildered. Let me help sort that out for you.\nFirst off, you\u0026rsquo;ll need to remember that the first thing you must tell find is where to begin looking. If you don\u0026rsquo;t tell it where to begin the search, how can you ever expect to find anything in an efficient manner? So, very simply, you could use find as a sort of alternate form of ls like this\n1 find /home/john/Music/jazz And find will dutifully list out all the files in folders it can get its paws on. This is the absolute most basic of basic ways to use find.\nBy Name Lets try something a little more useful. Next up, we have the -name switch which will allow us to use glob patterns to search for files. You\u0026rsquo;re probably familiar with glob patterns from DOS and Bash already, things like ls *.jpg to list all jpeg files. Well, lets see what the equivalent to that looks like with find.\n1 find /home/john/Music/jazz -name \u0026#34;*.mp3\u0026#34; This will only list out files that end with .mp3. If you have other file types then you might want to try one of these:\n1 2 3 4 find /home/john/Music/jazz -name \u0026#34;*.aac\u0026#34; find /home/john/Music/jazz -name \u0026#34;*.flac\u0026#34; find /home/john/Music/jazz -name \u0026#34;*.wav\u0026#34; find /home/john/Music/jazz -name \u0026#34;*.ogg\u0026#34; By Regular Expression As you can see the possibilities for file name matching are only limited by your imagination - well, your imagination and the limits of glob patterns. I personally find glob patterns to be rather limiting, and some people forget that glob patterns are not regular expressions because they look so similar. Lucky for us find lets us use regular expressions as well. We can do the exact same searches as above, but with the -regex switch instead of the -name switch, like so:\n1 2 3 4 find /home/john/Music/jazz -regex \u0026#34;.*\\.aac\u0026#34; find /home/john/Music/jazz -regex \u0026#34;.*\\.flac\u0026#34; find /home/john/Music/jazz -regex \u0026#34;.*\\.wav\u0026#34; find /home/john/Music/jazz -regex \u0026#34;.*\\.ogg\u0026#34; Being Insensitive Ok that\u0026rsquo;s nice, but seriously, I can\u0026rsquo;t remember the file name, so a case sensitive match doesn\u0026rsquo;t work for me! No problem, just use the case insensitive version -iname. So if you wanted to find that 1994 tax return and you had some vague idea of what it was probably named, you might try something like this.\n1 find /home/john/Accounting -iname \u0026#34;*tAxES*1994*\u0026#34; and -iregex works about the same way\n1 find /home/john/Accounting -iregex \u0026#34;.*\\(tax\\|taxes\\|return\\|1994\\).*\\(tax\\|taxes\\|return\\|1994\\).*\u0026#34; This regex should find examples such as \u0026ldquo;1994 - State Tax Return.doc\u0026rdquo; or \u0026ldquo;l33t hax0R taXeS from 1994.pdf\u0026rdquo;\nDoing Stuff With What You Find First off, think of find as a tool for not for \u0026ldquo;finding\u0026rdquo; but for \u0026ldquo;choosing\u0026rdquo; what you want to work on. The power of the find command becomes more obvious when we start being able to apply commands to each file. This means we can do things in batches, like we could rename a bunch of files from .txt to .doc or we could use imagemagick to resize a bunch of pictures for example.\nA Case Scenario Lets say we have some mp3s of Bobby McFerrin\u0026rsquo;s album \u0026ldquo;Don\u0026rsquo;t Worry Be Happy\u0026rdquo; and we want to add his name to the beginning of each mp3 file so that we\u0026rsquo;re more organized. If you do this through a GUI you\u0026rsquo;re going to be sitting there for a long time typing the same thing over and over again, clicking waiting, typing, over and over. If you do this with the shell, you will merely have to think for a small moment to write the proper command, and then everything is done for you. If you don\u0026rsquo;t like the result, it\u0026rsquo;s just as easy to change things back to the way they were, you can either run the reverse command, or you can just delete the copy you were working on. You, um, were working on a copy\u0026hellip; right? :P\nI\u0026rsquo;m going to pretend that I have a folder named \u0026ldquo;Don\u0026rsquo;t Worry Be Happy\u0026rdquo; and that in it, I have several mp3 files from Bobby McFerrin. In my case I just have some example files named foo.mp3 and bar.mp3 etc.. Now the first thing to do, is to get find to find the right files. Lets write an example find command and check its output to be sure that we\u0026rsquo;ll be operating on exactly the files we want to change. I will run something like this:\n1 2 cd /home/john/Music/jazz find \u0026#34;Don\u0026#39;t Worry Be Happy\u0026#34; That seems reasonable right? I think so too, lets look at the output\n1 2 3 4 5 Don\u0026#39;t Worry Be Happy/ Don\u0026#39;t Worry Be Happy/foo.mp3 Don\u0026#39;t Worry Be Happy/qux.mp3 Don\u0026#39;t Worry Be Happy/bar.mp3 Don\u0026#39;t Worry Be Happy/baz.mp3 Trimming Unwanted Folders Uh oh, look at that, the find command is including the actual folder in the list of files it found! We don\u0026rsquo;t want to change the folder name, so lets update this command to only find files.\n1 find \u0026#34;Don\u0026#39;t Worry Be Happy\u0026#34; -type f And now we get\n1 2 3 4 Don\u0026#39;t Worry Be Happy/foo.mp3 Don\u0026#39;t Worry Be Happy/qux.mp3 Don\u0026#39;t Worry Be Happy/bar.mp3 Don\u0026#39;t Worry Be Happy/baz.mp3 That\u0026rsquo;s much better. Of course, we could have also used a glob pattern with -name or a regular expression, but I wanted to illustrate another handy feature of the find command, which is that you can tell it to only select files or only select directories, this can be handy for normalizing permissions as you\u0026rsquo;ll see later.\nRunning Some Test Commands Now lets start getting something done with these files. Before we do anything real we\u0026rsquo;ll run a test command just so we can double check that our command is running the way we want it to.\nTo run a command on each file found, we use the -exec switch.\nNOTE: There is a small quirk about the -exec switch: you must tell -exec where the command ends. Most languages do this with a semi-colon ; but bash will gobble up your semi-colon before giving it to -exec because bash is greedy and bash thinks that you mean you want to run some other command after running find. To prevent bash from swallowing our semi-colon, we need to escape it with the backslash like this \\; and then the semi-colon will be given to -exec and everyone is happy.\n1 find \u0026#34;Don\u0026#39;t Worry Be Happy\u0026#34; -type f -exec echo \u0026#34;The file is: {}\u0026#34; \\; and we get\n1 2 3 4 The file is: Don\u0026#39;t Worry Be Happy/foo.mp3 The file is: Don\u0026#39;t Worry Be Happy/qux.mp3 The file is: Don\u0026#39;t Worry Be Happy/bar.mp3 The file is: Don\u0026#39;t Worry Be Happy/baz.mp3 As you can see, still not much is happening yet, but we are getting there. The main thing to notice is that {} is the placeholder for the current file name. It means \u0026ldquo;put the current file name right here as if I had just typed it out\u0026rdquo;. Lets do something a little more meaningful next, lets actually put Bobby McFerrin\u0026rsquo;s name in front of each file.\nChanging The File Name 1 find \u0026#34;Don\u0026#39;t Worry Be Happy\u0026#34; -type f -exec echo \u0026#34;{}\u0026#34; | sed -e \u0026#34;s#^#Bobby McFerrin - #\u0026#34; \\; NOTE: most people usually use forward slashes with sed for substitution, but I prefer to use # by default because then you don\u0026rsquo;t need to escape your slashes. This is especially useful when dealing with file names.\nUh, oh what\u0026rsquo;s this?\n1 2 find: missing argument to `-exec\u0026#39; sed: can\u0026#39;t read ;: No such file or directory Running Multiple Commands Well, yes we do need to escape the semi-colon because of bash, but once we start getting a little more complicated, things break down again. The basic solution is to feed the entire string of commands to bash directly. Bash can be invoked with the -c switch which does much the same thing as -exec, namely it runs a command (\u0026ldquo;c\u0026rdquo; for \u0026ldquo;command\u0026rdquo;, get it?).\n1 find \u0026#34;Don\u0026#39;t Worry Be Happy\u0026#34; -type f -exec bash -c \u0026#39;echo $1 | sed -e \u0026#34;s#^#Bobby McFerrin - #\u0026#34;\u0026#39; _ \u0026#34;{}\u0026#34; \\; Doing this is certainly not as pretty, and instead of using {} in our list of commands, we use bash as we would if we were writing a script, in other words we pull our current file name from the first argument provided to bash which is always stored in the $1 variable. We then provide {} as the first argument to bash (the _ takes the place of the script filename since there isn\u0026rsquo;t one). Notice that the entire script is now wrapped in single quotes, we do this so that -exec knows what to feed bash -c as the command and what to feed as the arguments.\nOk so what does that command give us?\n1 2 3 4 Bobby McFerrin - Don\u0026#39;t Worry Be Happy/foo.mp3 Bobby McFerrin - Don\u0026#39;t Worry Be Happy/qux.mp3 Bobby McFerrin - Don\u0026#39;t Worry Be Happy/bar.mp3 Bobby McFerrin - Don\u0026#39;t Worry Be Happy/baz.mp3 Hmm, not quite what we wanted. If we had wanted to rename the entire directory we could have done that, no problem and that would have only taken a single command. The filename in this case is the entire file path, starting with the directory name, so simply using ^ in the regular expression to replace the beginning of the file name is not going to work, we\u0026rsquo;ll need to be more specific. Luckily, this is a very simple and easy change because I\u0026rsquo;m already using # signs for the substitution so no escaping is needed, just change the ^ caret to a / forward slash.\n1 find \u0026#34;Don\u0026#39;t Worry Be Happy\u0026#34; -type f -exec bash -c \u0026#39;echo $1 | sed -e \u0026#34;s#/#/Bobby McFerrin - #\u0026#34;\u0026#39; _ \u0026#34;{}\u0026#34; \\; Now this command gets is the following output\n1 2 3 4 Don\u0026#39;t Worry Be Happy/Bobby McFerrin - foo.mp3 Don\u0026#39;t Worry Be Happy/Bobby McFerrin - qux.mp3 Don\u0026#39;t Worry Be Happy/Bobby McFerrin - bar.mp3 Don\u0026#39;t Worry Be Happy/Bobby McFerrin - baz.mp3 Awesome, much better, now to write up a full command to actually rename these files.\nTesting The Real Thing 1 find \u0026#34;Don\u0026#39;t Worry Be Happy\u0026#34; -type f -exec bash -c \u0026#39;echo \u0026#34;mv\u0026#34; \u0026#34;$1\u0026#34; \u0026#34;$(echo \u0026#34;$1\u0026#34; | sed -e \u0026#34;s#/#/Bobby McFerrin - #\u0026#34;)\u0026#34;\u0026#39; _ \u0026#34;{}\u0026#34; \\; And that gives us\n1 2 3 4 mv Don\u0026#39;t Worry Be Happy/foo.mp3 Don\u0026#39;t Worry Be Happy/Bobby McFerrin - foo.mp3 mv Don\u0026#39;t Worry Be Happy/qux.mp3 Don\u0026#39;t Worry Be Happy/Bobby McFerrin - qux.mp3 mv Don\u0026#39;t Worry Be Happy/bar.mp3 Don\u0026#39;t Worry Be Happy/Bobby McFerrin - bar.mp3 mv Don\u0026#39;t Worry Be Happy/baz.mp3 Don\u0026#39;t Worry Be Happy/Bobby McFerrin - baz.mp3 Refactoring Lets refactor just a touch, so our script is more friendly and easier to work with. Using single quotes to feed the command to bash means that whatever we put between those single quotes may span as many lines as we wish. Also we\u0026rsquo;re getting happy with the quotes. Bash likes quotes, always quote more, not less, especially when you\u0026rsquo;re dealing with files that have spaces in their names.\n1 2 3 4 5 find \u0026#34;Don\u0026#39;t Worry Be Happy\u0026#34; -type f -exec bash -c \u0026#39; orig_name=\u0026#34;$1\u0026#34; new_name=\u0026#34;$(echo \u0026#34;$1\u0026#34; | sed -e \u0026#34;s#/#/Bobby McFerrin - #\u0026#34;)\u0026#34; echo moving \\\u0026#34;\u0026#34;$orig_name\u0026#34;\\\u0026#34; to \\\u0026#34;\u0026#34;$new_name\u0026#34;\\\u0026#34; \u0026#39; _ \u0026#34;{}\u0026#34; \\; now we get\n1 2 3 4 moving \u0026#34;Don\u0026#39;t Worry Be Happy/foo.mp3\u0026#34; to \u0026#34;Don\u0026#39;t Worry Be Happy/Bobby McFerrin - foo.mp3\u0026#34; moving \u0026#34;Don\u0026#39;t Worry Be Happy/qux.mp3\u0026#34; to \u0026#34;Don\u0026#39;t Worry Be Happy/Bobby McFerrin - qux.mp3\u0026#34; moving \u0026#34;Don\u0026#39;t Worry Be Happy/bar.mp3\u0026#34; to \u0026#34;Don\u0026#39;t Worry Be Happy/Bobby McFerrin - bar.mp3\u0026#34; moving \u0026#34;Don\u0026#39;t Worry Be Happy/baz.mp3\u0026#34; to \u0026#34;Don\u0026#39;t Worry Be Happy/Bobby McFerrin - baz.mp3\u0026#34; Renaming For Real Cool, lets try this thing without a safety net, go ahead and add in the move command - don\u0026rsquo;t forget your quotes. We\u0026rsquo;ll also put in an ls before and after, so we can double check our results.\n1 2 3 4 5 6 7 8 9 ls \u0026#34;Don\u0026#39;t Worry Be Happy\u0026#34; find \u0026#34;Don\u0026#39;t Worry Be Happy\u0026#34; -type f -exec bash -c \u0026#39; orig_name=\u0026#34;$1\u0026#34; new_name=\u0026#34;$(echo \u0026#34;$1\u0026#34; | sed -e \u0026#34;s#/#/Bobby McFerrin - #\u0026#34;)\u0026#34; echo moving \\\u0026#34;\u0026#34;$orig_name\u0026#34;\\\u0026#34; to \\\u0026#34;\u0026#34;$new_name\u0026#34;\\\u0026#34; mv \u0026#34;$orig_name\u0026#34; \u0026#34;$new_name\u0026#34; \u0026#39; _ \u0026#34;{}\u0026#34; \\; ls \u0026#34;Don\u0026#39;t Worry Be Happy\u0026#34; echo \u0026#34;DONE\u0026#34; And that gives us\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 john@localhost ~/Music/jazz$ ls \u0026#34;Don\u0026#39;t Worry Be Happy\u0026#34; bar.mp3 baz.mp3 foo.mp3 qux.mp3 john@localhost ~/Music/jazz$ find \u0026#34;Don\u0026#39;t Worry Be Happy\u0026#34; -type f -exec bash -c \u0026#39; \u0026gt; orig_name=\u0026#34;$1\u0026#34; \u0026gt; new_name=\u0026#34;$(echo \u0026#34;$1\u0026#34; | sed -e \u0026#34;s#/#/Bobby McFerrin - #\u0026#34;)\u0026#34; \u0026gt; echo moving \\\u0026#34;\u0026#34;$orig_name\u0026#34;\\\u0026#34; to \\\u0026#34;\u0026#34;$new_name\u0026#34;\\\u0026#34; \u0026gt; mv \u0026#34;$orig_name\u0026#34; \u0026#34;$new_name\u0026#34; \u0026gt; \u0026#39; _ \u0026#34;{}\u0026#34; \\; moving \u0026#34;Don\u0026#39;t Worry Be Happy/foo.mp3\u0026#34; to \u0026#34;Don\u0026#39;t Worry Be Happy/Bobby McFerrin - foo.mp3\u0026#34; moving \u0026#34;Don\u0026#39;t Worry Be Happy/qux.mp3\u0026#34; to \u0026#34;Don\u0026#39;t Worry Be Happy/Bobby McFerrin - qux.mp3\u0026#34; moving \u0026#34;Don\u0026#39;t Worry Be Happy/bar.mp3\u0026#34; to \u0026#34;Don\u0026#39;t Worry Be Happy/Bobby McFerrin - bar.mp3\u0026#34; moving \u0026#34;Don\u0026#39;t Worry Be Happy/baz.mp3\u0026#34; to \u0026#34;Don\u0026#39;t Worry Be Happy/Bobby McFerrin - baz.mp3\u0026#34; john@localhost ~/Music/jazz$ ls \u0026#34;Don\u0026#39;t Worry Be Happy\u0026#34; Bobby McFerrin - bar.mp3 Bobby McFerrin - baz.mp3 Bobby McFerrin - foo.mp3 Bobby McFerrin - qux.mp3 A Better Alternative Awesome! Er\u0026hellip; kind of\u0026hellip; so you mean I have to type out all that gook every time I want to rename some files? Luckily, no. There is a perl utility called, oddly enough, rename and it makes renaming files like this a breeze. If you\u0026rsquo;re on Ubuntu, then you\u0026rsquo;ve already got rename, it lives in /usr/bin/rename and it comes from the util-linux package. Otherwise you\u0026rsquo;ll need to build it yourself or download one of the many prebuilt versions you can find on the net.\nCommand Glue There is a small and important distinction and option that you have with -exec and that is whether to run separate commands or one big long command. If you use the semi colon with exec, a separate command will be run for each file. If you use the plus sign, one big command will be run with all the files being provided on one line to the command.\nSeparate For example if you wanted to delete some files, you could do something like this\n1 find /some/folder -name \u0026#34;*.txt\u0026#34; -exec rm -rf \u0026#34;{}\u0026#34; \\; and if there were three files, foo, bar and baz, then behind the scenes it would look something like this\n1 2 3 rm -rf foo.txt rm -rf bar.txt rm -rf baz.txt Together If, however, you use a plus sign instead of the semi-colon (and you don\u0026rsquo;t need to escape the plus sign by the way)\n1 find /some/folder -name \u0026#34;*.txt\u0026#34; -exec rm -rf \u0026#34;{}\u0026#34; + then find will put the list of files all on one line and run only a single command, so behind the scenes it would look something like this\n1 rm -rf foo.txt bar.txt baz.txt This only works if your list of files is the last argument, you can\u0026rsquo;t use this with the move command for example because\ndon\u0026rsquo;t do this, this is bad mmmmkay? 1 find /some/folder -name \u0026#34;*.txt\u0026#34; -exec mv \u0026#34;{}\u0026#34; /some/other/folder + just isn\u0026rsquo;t correct. So if you want to use + then {} must be the last argument to your command.\nThe main consideration here is that if you have a lot of files, it will probably be faster to run the command once, giving it all the file names, than it will be to run the command on every file individually.\nSome Common Useful Stuff So renaming was kind of pointless, except to learn the glorious nirvana of find, now what more can we ask for?\nNormalize file and folder permissions. 1 2 find /some/folder -type f -exec chmod 644 \u0026#34;{}\u0026#34; + find /some/folder -type d -exec chmod 755 \u0026#34;{}\u0026#34; + Sometimes permissions get all wacky and if you want to set them back to relatively sane defaults you could use something like this.\nGiving Ownership to Your Team. If you wanted to for example add a folder to your workgroup so that all members have and will continue to have access to the files in it, you may wish to set the sticky bit.\n1 2 chmod -R g+w /some/folder find /some/folder -type d -exec chmod g+s \u0026#34;{}\u0026#34; + The sticky bit is only relevant for folders, so we use the find command to specify only folders with -type d. Granting write permissions is easily done with chmod by itself using the -R switch meaning recursive.\nResize a bunch of JPEGs 1 2 find /home/john/Pictures/Summer/Vacation -iname \u0026#34;*.jpg\u0026#34; -exec mogrify -resize 50% \u0026#34;{}\u0026#34; + find /home/john/Pictures/Summer/Vacation -iname \u0026#34;*.jpg\u0026#34; -exec mogrify -strip \u0026#34;{}\u0026#34; + You can easily and quickly strip out identifying information like date, time or GPS coordinates from your pictures to protect your personal privacy with the -strip switch.\nSwap out sets of vhosts 1 2 find /etc/apache2/sites-enabled -iname \u0026#34;proxied_*\u0026#34; -exec rm -rf \u0026#34;{}\u0026#34; + find /etc/apache2/sites-available -iname \u0026#34;nonproxied_*\u0026#34; -exec ln -s \u0026#34;{}\u0026#34; /etc/apache2/sites-enabled \\; Lets say you\u0026rsquo;d like to be able to switch back and forth between Apache HTTPD as your main web server, and putting apache behind a reverse proxy with nginx while you learn about reverse proxies and nginx and get your configuration set up just the way you want it. If you make two sets of vhosts and have the names for each type begin with some unique identifier like \u0026ldquo;proxied\u0026rdquo; then you can easily use find to switch back and forth between the two different vhost configurations.\nTo switch between the proxied and non-proxied styles of apache all you need to do is delete the symlinks to the proxied vhosts and re-symlink the non-proxied vhosts. This is what the above example accomplishes.\nCover Photo\nCredit: Markus Spiske Iar\n","date":"2010-06-16T18:00:00Z","image":"http://www.rocksolidwebdesign.com/images/unsplash/markus-spiske-iar-afB0QQw-unsplash-crop.png","permalink":"http://www.rocksolidwebdesign.com/p/bash-power-commands/","title":"Bash Power Commands"},{"content":"As humans, we love to customize things. Custom wallpaper, custom icons, custom paintjobs for our cars and smartphones. Customize something you probably use every day: your terminal\u0026rsquo;s command prompt.\nAwesome Sauce Bash Prompt Howto Let\u0026rsquo;s get busy! Put the following lines in your ~/.bashrc or ~/.bash_profile and next time you open a terminal it should just work.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 black=$(tput -Txterm setaf 0) red=$(tput -Txterm setaf 1) green=$(tput -Txterm setaf 2) yellow=$(tput -Txterm setaf 3) dk_blue=$(tput -Txterm setaf 4) pink=$(tput -Txterm setaf 5) lt_blue=$(tput -Txterm setaf 6) bold=$(tput -Txterm bold) reset=$(tput -Txterm sgr0) arr_smiley_color=(\u0026#34;$green\u0026#34; \u0026#34;$red\u0026#34;) arr_smiley_status=(\u0026#34;:)\u0026#34; \u0026#34;:(\u0026#34;) export PS1=\u0026#39;\\n\\[$bold\\]\\[$black\\][\\[$dk_blue\\]\\@\\[$black\\]]-[\\[$green\\]\\u\\[$yellow\\]@\\[$green\\]\\H\\[$black\\]]-[\\[$pink\\]\\w\\[$black\\]]\\[$reset\\]\\n\\[${arr_smiley_color[$?\u0026gt;0]}\\]${arr_smiley_status[$?\u0026gt;0]} \\[$reset\\]\\$ \u0026#39; It\u0026rsquo;s kind of complicated, but really pretty simple. There are sequences of characters that bash treats in a special way. Most notably some of them cause bash to change the color of its output in your terminal. You can use these special sequences (called escape codes) in your bash prompt to make things look cool.\nYou could memorize all the numbers and codes for each color or you could use the handy tput command to retrieve the various color codes for you. I\u0026rsquo;ve already done the work of labeling which number translates in to what style, so then all you need to do is use them in your prompt. All you need to remember is that each of these codes must be surrounded by \\[ and \\]. With that in mind, feel free to play with and change the colors all you like.\nSwap out the different color names on line 14 to change it up and suit your taste. I\u0026rsquo;ve also got a fancy little bit of trickery as you\u0026rsquo;ll see there on lines 12 and 13. The prompt is evaluated after every command, and so we can actually check conditional expressions. In this case I\u0026rsquo;m checking to see if the last command failed or succeeded. If the previous command failed you get a red sad face, if it succeeded then you get a green happy face. This prompt also spans two lines as you can see by using the standard \\n escape character for new line.\nThere are some other, bash prompt specific, escape characters used here that you may not have been aware of: the current time for example is \\@. Check the bash manual pages for a\ncomplete list of the escape sequences available on the bash prompt .\nCover Photo\nCredit: Ali Shah Lakhani\n","date":"2010-06-15T18:00:00Z","image":"http://www.rocksolidwebdesign.com/images/unsplash/ali-shah-lakhani-sp1BZ1atp7M-unsplash-crop.png","permalink":"http://www.rocksolidwebdesign.com/p/cool-bash-prompt/","title":"Cool Bash Prompt"}]